/**
MST (Min Spanning Tree) - минимално (с минимално общо тегло на ребрата) покриващо дърво
Алгоритъм на Прим
Приложения:
* намиране на най-леките ребра в граф
* намиране на bottleneck
* минимизиране на тегло на граф
Забележка: MST може да се приложи само върху свързан граф!
Сложност: O(N log(M))
Визуализация на алгоритъма: https://www.cs.usfca.edu/~galles/visualization/Prim.html
*/

#include<iostream>
#define INF 99999999
#define MAXN 1024
using namespace std;
int a[MAXN][MAXN], n, m;
int tree[MAXN], p[MAXN], depth[MAXN];
bool used[MAXN];

void prim(int root){
    used[root] = 1;                                              //коренът е обходен
    depth[root] = 0;                                             //дълбочината на корена е 0

    for(int i=1; i<=n; i++){                                     //за всеки връх присвояваме теглото между него и корена
        tree[i] = a[root][i];
        p[i] = root;                                             //и добавяме за родител корена
    }

    p[root] = 0;                                                 //родител на корена е 0
    tree[root] = INF;                                            //дължина от корена до себе си не съществува
    int maxDist, j = 0;

    for(int l=0; l<n-1; l++){                                    //n-1 пъти се върти цикъла
        maxDist = 0, j = -1;                                     //максималната дължина е 0 и е към несъществуващ (-1) връх
        for(int i=1; i<=n; i++){                                 //за всеки връх
            if (tree[i] > maxDist && !used[i]){                  //ако дължината до корена е по-голяма от максималната и той е необходен
                maxDist = tree[i];                               //присвояваме това ребро за максимално
                j = i;                                           //и отбелязваме кой е върха
            }
        }
        used[j] = 1;                                           //последния отбелязан връх е обходен
        for(int i=1; i<=n; i++){                               //за всеки връх
            if (tree[i] < a[j][i] && !used[i]){                //ако съшествува по-голямо ребро до някой от другите върхове и той не е използван
                tree[i] = a[j][i];                             //обновяваме списъка на максималните ребра
                p[i] = j;                                      //и родител на текущото ребро става отбелязаното
                depth[i] = depth[j]+1;                         //а дълбочината му - това на предшественика +1
            }
        }
    }
    for(int l=0; l<n/2; l++)                                  //n/2 пъти
        for(int i=1; i<=n; i++)                               //оптимизираме дълбочината на дървото
            depth[i] = depth[p[i]]+1;
}


main()
{
    int x, y, z;
    cin>>n>>m;
    for(int i=0; i<m; i++){                         //строим граф в матрица на теглата
        cin>>x>>y>>z;
        a[x][y]=z;
        a[y][x]=z;
    }


    int root;                                     //определяме начален връх (корен на дървото)
    cin>>root;
    prim(root);

    for(int i=0; i<=n; i++){
        cout<<i<<"-> ";
        for(int j=0; j<=n; j++){
            if(p[j]==i)cout<<j<<" ";
        }
        cout<<endl;
    }


    return 0;
}


