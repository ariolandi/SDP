#include<iostream>
#define INF 99999999
using namespace std;
int a[1024][1024], n, m;
int tree[1024], p[1024], depth[1024];
bool used[1024];

void prim(int root){
    used[root]=1;                                              //първия връх е обходен
    depth[root]=0;                                             //дълбочината на нулевия връх е 0

    for(int i=1; i<=n; i++){                                   //за всеки връх
        tree[i]=a[root][i];                                    //присвояваме теглото между него и първия
        p[i]=root;                                             //и добавяме за родител първия връх
    }

    p[root]=0;                                                 //родител на първия връх е 0
    tree[root]=INF;                                            //дължина от първия до първия връх не съществува
    int maxDist, j=0;

    for(int l=0; l<n-1; l++){                                 //n-1 пъти се върти цикъла
        maxDist=0, j=-1;                                      //максималната дължина е 0 и е към -1 връх
        for(int i=1; i<=n; i++){                             //за всеки връх
            if (tree[i]>maxDist && used[i]==0){              //ако дължината му от първия е по-голяма от максималната и той е необходен
                maxDist=tree[i];                             //присвояваме това ребро за максимално
                j=i;                                         //и отбелязваме кой е върха
            }
        }
        used[j]=1;                                           //последния отбелязан връх е обходен
        for(int i=1; i<=n; i++){                             //за всеки връх
            if (tree[i]<a[j][i] && used[i]==0){              //ако съшествува по-голямо ребро до някой от другите върхове и той не е използван
                tree[i]=a[j][i];                             //обновяваме списъка на максималните ребра
                p[i]=j;                                      //и родител на текущото ребро става отбелязаното
                depth[i]=depth[j]+1;                         //а дълбочината му - това на предшественика +1
            }
        }
    }
    for(int l=0; l<n/2; l++)                                 //n/2 пъти
        for(int i=1; i<=n; i++)depth[i]=depth[p[i]]+1;      //оптимизираме дълбочината на дървото
}


main()
{
    int x, y, z;
    cin>>n>>m;
    for(int i=0; i<m; i++){                     //строим граф в матрица на теглата
        cin>>x>>y>>z;
        a[x][y]=z;
        a[y][x]=z;
    }


    int root=1;                                     //определяме начален връх (корен на дървото)
    prim(root);                                     //викаме Прим

  for(int i=0; i<=n; i++){
        cout<<i<<"-> ";
        for(int j=0; j<=n; j++){
            if(p[j]==i)cout<<j<<" ";
        }
        cout<<endl;
  }


    return 0;
}

/*
Построяваме дървото на принципа на родителите и наследниците. Т.е. крайният резултат е списък, съдържащ родителя на всеки връх.
*/

/*
За минимално покриващо дърво:

void prim(int root){
    used[root]=1;                                              //първия връх е обходен
    depth[root]=0;                                             //дълбочината на нулевия връх е 0

    for(int i=1; i<=n; i++){                                   //за всеки връх
        tree[i]=a[root][i];                                    //присвояваме теглото между него и първия
        p[i]=root;                                             //и добавяме за родител първия връх
    }

    p[root]=0;                                                 //родител на първия връх е 0
    tree[root]=INF;                                            //дължина от първия до първия връх не съществува
    int minDist, j=0;

    for(int l=0; l<n-1; l++){                                 //n-1 пъти се върти цикъла
        minDist=0, j=-1;                                      //минималната дължина е 0 и е към -1 връх
        for(int i=1; i<=n; i++){                             //за всеки връх
            if (tree[i]<minDist && used[i]==0){              //ако дължината му от първия е по-малка от минималната и той е необходен
                minDist=tree[i];                             //присвояваме това ребро за минимално
                j=i;                                         //и отбелязваме кой е върха
            }
        }
        used[j]=1;                                           //последния отбелязан връх е обходен
        for(int i=1; i<=n; i++){                             //за всеки връх
            if (tree[i]>a[j][i] && used[i]==0){              //ако съшествува по-малко ребро до някой от другите върхове и той не е използван
                tree[i]=a[j][i];                             //обновяваме списъка на минималните ребра
                p[i]=j;                                      //и родител на текущото ребро става отбелязаното
                depth[i]=depth[j]+1;                         //а дълбочината му - това на предшественика +1
            }
        }
    }
    for(int l=0; l<n/2; l++)                                 //n/2 пъти
        for(int i=1; i<=n; i++)depth[i]=depth[p[i]]+1;      //оптимизираме дълбочината на дървото
}

*/

